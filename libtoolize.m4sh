m4_define([_m4_divert(SCRIPT)], 100)
m4_divert_push([SCRIPT])#! /bin/sh
# @configure_input@

# libtoolize (GNU @PACKAGE@@TIMESTAMP@) @VERSION@
# Written by Gary V. Vaughan <gary@gnu.org>, 2003

# Copyright (C) 2003, 2004, 2005 Free Software Foundation, Inc.
# This is free software; see the source for copying conditions.  There is NO
# warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.

# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful, but
# WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
# General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, a copy can be downloaded from
# http://www.gnu.org/copyleft/gpl.html, or by writing to the Free
# Software Foundation, Inc., 59 Temple Place - Suite 330, Boston,
# MA 02111-1307, USA.
#
# As a special exception to the GNU General Public License, if you
# distribute this file as part of a program that contains a
# configuration script generated by Autoconf, you may include it under
# the same distribution terms that you use for the rest of that program.

# Usage: $progname [OPTION]...
#
# Prepare a package to use libtool.
#
# -c, --copy            copy files rather than symlinking them
#     --debug           enable verbose shell tracing
# -n, --dry-run         print commands rather than running them
# -f, --force           replace existing files
# -i, --install         copy missing auxiliary files
#     --ltdl[=DIR]      install libltdl in a subdirectory [default: libltdl]
# -q, --quiet           work silently
# -v, --verbose         verbosely report processing
#     --version         print version information and exit
# -h, --help            print short or long help message
#
# You must `cd' to the top directory of your package before you run
# `$progname'.
#
# When reporting a bug, please describe a test case to reproduce it and
# include the following information:
#
#       host-triplet:	@host_triplet@
#       $progname:	(GNU @PACKAGE@@TIMESTAMP@) @VERSION@
#       automake:		$automake_version
#       autoconf:		$autoconf_version
#
# Report bugs to <bug-libtool@gnu.org>.

PROGRAM=libtoolize

AS_SHELL_SANITIZE
$as_unset CDPATH

m4_include([getopt.m4sh])

TAR=tar

# Command line options:
opt_force=false
opt_install=false
opt_link=:
opt_debug=:

seen_libtool=false
seen_ltdl=false

# Collect flags to pass into libltdl libtoolize
libtoolize_flags=

# Locations for important files:
: ${_lt_pkgvdatadir="@pkgvdatadir@"}
prefix=@prefix@
datadir=@datadir@
auxdir=
m4dir=
ltdldir=
configure_ac=configure.in


# Parse options once, thoroughly.  This comes as soon as possible in
# the script to make things like `libtoolize --version' happen quickly.
{
  # sed scripts:
  my_sed_single_opt='1s/^\(..\).*$/\1/;q'
  my_sed_single_rest='1s/^..\(.*\)$/\1/;q'
  my_sed_long_opt='1s/^\(--[[^=]]*\)=.*/\1/;q'
  my_sed_long_arg='1s/^--[[^=]]*=//'

  while test "$#" -gt 0; do
    opt="$1"
    shift
    case $opt in
      --copy|-c)	opt_link=false
      			libtoolize_flags="$libtoolize_flags --copy"
	    		;;

      --debug)		func_echo "enabling shell trace mode"
      			libtoolize_flags="$libtoolize_flags --debug"
			opt_debug='set -x'
			$opt_debug
			;;

      --dry-run|-n)	if $opt_dry_run; then :; else
			  opt_dry_run=:
			  RM="$ECHO $RM"
			  test -n "$LN_S" && LN_S="$ECHO $LN_S"
			  CP="$ECHO $CP"
			  MKDIR="$ECHO $MKDIR"
			  TAR="$ECHO $TAR"
			fi
      			libtoolize_flags="${libtoolize_flags} --dry-run"
			;;

      --force|-f)	opt_force=:
      			libtoolize_flags="${libtoolize_flags} --force"
			;;

      --install|-i)	opt_install=:
      			libtoolize_flags="${libtoolize_flags} --install"
			;;

      --ltdl)		ltdldir=libltdl
      			if test "$#" -gt 0; then
			  case $1 in
			    -*)				;;
			    *)  ltdldir="$1"; shift	;;
			  esac
			fi
			;;

      --quiet|--automake|-q) # --automake is for 1.5 compatibility
			opt_quiet=:
      			libtoolize_flags="${libtoolize_flags} --quiet"
			;;

      --verbose|-v)	opt_verbose=:
      			libtoolize_flags="${libtoolize_flags} --verbose"
			;;

      # Separate optargs to long options:
      --*=*)
      			arg=`$ECHO "X$opt" | $Xsed -e "$my_sed_long_arg"`
			opt=`$ECHO "X$opt" | $Xsed -e "$my_sed_long_opt"`
			set dummy "$opt" "$arg" ${1+"$@"}
			shift
			;;

      # Separate non-argument short options:
      -c*|-i*|-f*|-n*|-q*|-v*)
			rest=`$ECHO "X$opt" | $Xsed -e "$my_sed_single_rest"`
			opt=`$ECHO "X$opt" | $Xsed -e "$my_sed_single_opt"`
			set dummy "$opt" "-$rest" ${1+"$@"}
			shift
			;;

      -\?|-h)		func_usage					;;
      --help)		func_help					;;
      --version)	func_version					;;
      --)		break						;;
      -*)		func_fatal_help "unrecognized option \`$opt'"	;;
      *)		func_fatal_help "too many arguments"		;;
    esac
  done
}


# func_copy srcfile destfile
# A wrapper for func_copy_cb that accepts arguments in the same order
# as the cp(1) shell command.
func_copy ()
{
    $opt_debug

    test -f "$1" || \
      { func_error "\`$1' not copied:  not a regular file"; return 1; }

    my_f1=`$ECHO "X$1" | $Xsed -e "$basename"`

    if test -d "$2"; then

      func_copy_cb "$my_f1" \
	`$ECHO "X$1" | $Xsed -e "$dirname"` "$2"

    else

      # Supporting this would mean changing the timestamp:
      test "X$my_f1" = X`$ECHO "X$2" | $Xsed -e "$basename"` \
        || func_fatal_error "func_copy() cannot change filename on copy"

      func_copy_cb "$my_f1" \
        `$ECHO "X$1" | $Xsed -e "$dirname"` \
        `$ECHO "X$2" | $Xsed -e "$dirname"`

    fi

    return $copy_return_status # set in func_copy_cb
}


# func_copy_cb filename srcdir destdir
# If option `--copy' was specified, or soft-linking SRCFILE to DESTFILE fails,
# then try to copy SRCFILE to DESTFILE (without changing the timestamp if
# possible).
func_copy_cb ()
{
    $opt_debug
    my_file="$1"
    my_srcdir="$2"
    my_destdir="$3"
    copy_return_status=1

    # Libtool is probably misinstalled if this happens:
    test -f "$my_srcdir/$my_file" || \
      { func_error "\`$my_file' not found in \`$my_srcdir'"; return; }

    func_mkdir_p "$my_destdir"

    $RM "$my_destdir/$my_file"
    if $opt_link && $LN_S "$my_srcdir/$my_file" "$my_destdir/$my_file"; then
      $opt_quiet || func_echo "copying file \`$my_destdir/$my_file'"
      copy_return_status=0
    elif { ( cd "$my_srcdir" 2>/dev/null && $TAR chf - "$my_file" 2>/dev/null; ) \
        | ( umask 0 && cd "$my_destdir" 2>/dev/null && "$TAR" xf - > /dev/null 2>&1; ); } ; then
      $opt_quiet || func_echo "copying file \`$my_destdir/$my_file'"
      copy_return_status=0
    elif $CP -p "$my_srcdir/$my_file" "$my_destdir/$my_file"; then
      $opt_quiet || func_echo "copying file \`$my_destdir/$my_file'"
      copy_return_status=0
    else
      func_error "can not copy \`$my_srcdir/$my_file' to \`$my_destdir/'"
      exit_status=$EXIT_FAILURE
    fi
}


# func_copy_all_from_path [-r] dirname srcpath destdir [glob_exclude]
# Search each : delimited directory in SRCPATH for a directory named
# DIRNAME.  Recursively copy the contents of the first match found
# to DESTDIR.
func_copy_all_from_path ()
{
    $opt_debug
    if test "X$1" = X-r; then
      my_args=-r
      shift
    fi

    my_dirname="$1"
    my_srcpath="$2"
    my_destdir="$3"
    my_globexc="$4"

    save_IFS="$IFS"; IFS=:
    for myvdir in $my_srcpath; do
      IFS="$save_IFS"
      test "X$my_dirname" = X. || myvdir="$myvdir/$my_dirname"
      if test -d "$myvdir"; then
        func_copy_all_files $my_args "$myvdir" "$my_destdir" "$my_globexc"
        break
      fi
    done
    IFS="$save_IFS"
}


# func_copy_all_files [-r] srcdir destdir [glob_exclude] [copy_cb=func_copy_cb]
# For each file in SRCDIR, then try to copy the file to DESTDIR by calling
# COPY_CB with the src and dest files.  With the `-r' option, recurse into
# subdirectories of srcdir too.  If GLOB_EXCLUDE is given, exclude any
# matching filenames from the copy.  If COPY_CB is passed, then the check
# for overwriting without opt_force is the callbacks responsibility:  This
# allows using callbacks like func_serial_update, which perform their own
# checks to decide whether to overwrite the dest file.
func_copy_all_files ()
{
    $opt_debug
    my_opt_recurse=false
    if test "X$1" = X-r; then
      my_opt_recurse=:
      shift
    fi

    my_srcdir="$1"
    my_destdir="$2"
    my_glob_exclude="$3"
    my_copy_cb="${4-func_copy_cb}"

    my_srcfiles=
    my_basedir="$my_srcdir"
    my_srcdirs="$my_srcdir"
    my_save_IFS="$IFS"
    IFS=:
    while test -n "$my_srcdirs"; do

      IFS="$my_save_IFS"
      my_srcdir=`$ECHO "X$my_srcdirs" | $Xsed -e 's,:.*,,g'`
      my_srcdirs=`$ECHO "X$my_srcdirs" | $Xsed -e 's,:*[[^:]][[^:]]*:*,,'`

      for my_filename in `cd "$my_srcdir" && ls`; do

         # ignore excluded filenames
        if test -n "$my_glob_exclude"; then
          eval 'case $my_filename in '$my_glob_exclude') continue ;; esac'
        fi

	# Add to the appropriate list
	if test -f "$my_srcdir/$my_filename"; then
	  my_srcfile=`$ECHO "X$my_srcdir/$my_filename" | $Xsed \
	      -e "s,^$my_basedir/*,,"`
	  my_srcfiles="$my_srcfiles${my_srcfiles:+:}$my_srcfile"
	elif $my_opt_recurse && test -d "$my_srcdir/$my_filename"; then
	  my_srcdirs="$my_srcdirs${my_srcdirs:+:}$my_srcdir/$my_filename"
	fi

      done
    done
    IFS="$my_save_IFS"

    func_copy_some_files "$my_srcfiles" "$my_basedir" \
      "$my_destdir" "$my_copy_cb"
}


# func_copy_some_files srcfile_spec srcdirs destdir [copy_cb=func_copy_cb]
# Call COPY_CB for each regular file named by the ':' delimited names in
# SRCFILE_SPEC first found in a directory from SRCDIRS.  The odd calling
# convention is needed to allow spaces in file and directory names.
func_copy_some_files ()
{
    $opt_debug
    my_srcfile_spec="$1"
    my_srcdirs="$2"
    my_destdir="$3"
    my_copy_cb="${4-func_copy_cb}"

    my_save_IFS="$IFS"
    IFS=:
    for my_filename in $my_srcfile_spec; do
      IFS=:
      for my_srcdir in $my_srcdirs; do
        IFS="$my_save_IFS"
        if test -f "$my_srcdir/$my_filename"; then
          if test "X$my_copy_cb" = Xfunc_copy_cb; then
	    $opt_force || if test -f "$my_destdir/$my_filename"; then
  	      $opt_quiet \
	        || func_error "\`$my_destdir/$my_filename' exists: use \`--force' to overwrite"
	      continue
	    fi
          fi
        else
          # Not a regular file
          continue
        fi

        $my_copy_cb "$my_filename" "$my_srcdir" "$my_destdir"
	break
      done
      IFS="$my_save_IFS"
    done
    IFS="$my_save_IFS"
}

# func_scan_files
# Scan configure.(ac|in) and aclocal.m4 (if present) for use of libltdl
# and libtool.  Possibly running some of these tools if necessary.
# Libtoolize affects the contents of aclocal.m4, and should be run before
# aclocal, so we can't use configure --trace which relies on a consistent
# configure.(ac|in) and aclocal.m4.
func_scan_files ()
{
    $opt_debug
    # Prefer configure.ac to configure.in
    test -f configure.ac && configure_ac=configure.ac
    test -f "$configure_ac" \
        || func_fatal_help "\`$configure_ac' does not exist"

    # check that existing directories from the list can be ls'ed
    test -n "`{ cd $_lt_pkgvdatadir && ls; } 2>/dev/null`" \
        || func_fatal_error "can not list files in \`$_lt_pkgvdatadir'"

    # Set local variables to reflect contents of configure.ac
    my_uses_autoconf=false
    my_sed_scan_configure_ac='s,#.*$,,; s,^dnl .*$,,; s, dnl .*$,,;
	/AC_INIT/ { s,^.*$,my_uses_autoconf=:,; p; };
	d'
    eval `$SED "$my_sed_scan_configure_ac" "$configure_ac"`

    $my_uses_autoconf || {
        func_verbose "$configure_ac: not using Autoconf"
	return
    }

    # ---------------------------------------------------- #
    # Probe macro usage in configure.ac and/or aclocal.m4. #
    # ---------------------------------------------------- #

    my_sed_traces='s,#.*$,,; s,^dnl .*$,,; s, dnl .*$,,;
    	/AC_CONFIG_AUX_DIR[[^_]]/  {
	    s,^.*AC_CONFIG_AUX_DIR([[[ 	]*\([^])]]*\).*$,auxdir=\1,; p;
        };
    	/AC_CONFIG_MACRO_DIR/   {
	    s,^.*AC_CONFIG_MACRO_DIR([[[ 	]*\([^])]]*\).*$,m4dir=\1,; p;
        };
	/A[[CM]]_PROG_LIBTOOL/ { s,^.*$,seen_libtool=:,; p; };
	/LT_INIT/	     { s,^.*$,seen_libtool=:,; p; };
	/LTDL_INIT/          { s,^.*$,seen_ltdl=:,; p; };
	/LT_WITH_LTDL/       { s,^.*$,seen_ltdl=:,; p; };
	/AC_LIB_LTDL/        { s,^.*$,seen_ltdl=:,; p; };
	/AC_WITH_LTDL/       { s,^.*$,seen_ltdl=:,; p; };
	d;'
    eval `cat aclocal.m4 "$configure_ac" 2>/dev/null | $SED "$my_sed_traces"`


    # ---------------- #
    # Validate auxdir. #
    # ---------------- #

    if test -n "$auxdir"; then
      # If $configure_ac contains AC_CONFIG_AUX_DIR, check that it was
      # not given in terms of a shell variable!
      case "$auxdir" in
      *\$*)
        func_fatal_error "can not handle variables in AC_CONFIG_AUX_DIR"
        ;;
      *);;
      esac
    else
      # Try to discover auxdir the same way it is discovered by configure.
      # Note that we default to the current directory.
      for dir in . .. ../..; do
        if test -f "$dir/install-sh"; then
          auxdir=$dir
          break
        elif test -f "$dir/install.sh"; then
          auxdir="$dir"
          break
        fi
      done
    fi

    # Just use the current directory if all else fails.
    test -n "$auxdir" || auxdir=.


    # ------------------------------ #
    # Find local m4 macro directory. #
    # ------------------------------ #

    # If AC_CONFIG_MACRO_DIR turned nothing up, we hunt for ACLOCAL_AMFLAGS
    # in `Makefile.am' for a `-I' argument.

    my_sed_aclocal_flags='/^[[ 	]]*ACLOCAL_[[A-Z_]]*FLAGS[[ 	]]*=/ {
	s,^[[^=]]*=[[ 	]]*\(.*\), \1,; q; };
	d'
    if test ! -n "$m4dir" && test -f Makefile.am; then
      my_m4dir_is_next=false
      for arg in `$SED "$my_sed_aclocal_flags" Makefile.am`; do
        if $my_m4dir_is_next; then
          m4dir="$arg"
          break
        else
          if test "X$arg" = "X-I"; then
            my_m4dir_is_next=:
          else
            my_m4dir_is_next=false
          fi
        fi
      done
    fi
}

# func_included_files searchfile
# Output INCLUDEFILE if SEARCHFILE m4_includes it, else output SEARCHFILE.
func_included_files ()
{
    $opt_debug
    my_searchfile="$1"

    my_include_regex=
    my_sed_include='
        /^[m4]_include(\[[.*\]])$/ { s,^[m4]_include(\[[\(.*\)\]])$,\1,; p; };
        d'

    if test -f "$my_searchfile"; then
      $ECHO "X$my_searchfile" | $Xsed
    fi

    # Only recurse when we don't care if all the variables we use get
    # trashed, since they are in global scope.
    for my_filename in `$SED "$my_sed_include" "$my_searchfile"`; do
      func_included_files $my_filename
    done
}


# func_serial filename [macro_regex]
# Output the value of the serial number comment in FILENAME, where the
# comment line must also match MACRO_REGEX, if given.
func_serial ()
{
    $opt_debug
    my_filename="$1"
    my_macro_regex="$2"
    my_sed_serial=['/^# serial [1-9][0-9.]*[ 	]*'"$my_macro_regex"'[ 	]*$/ {
	  s,^# serial \([1-9][0-9.]*\).*$,\1,; q;
	};
	d']

    # Search FILENAME and all the files it m4_includes for a serial number
    # in the file that AC_DEFUNs MACRO_REGEX.
    my_serial=
    for my_file in `func_included_files "$my_filename"`; do
      if test -z "$my_macro_regex" ||
         func_grep '^AC_DEFUN(\@<:@'"$my_macro_regex" "$my_file"
      then
        my_serial=`$SED -e "$my_sed_serial" "$my_file"`
	break
      fi
    done

    # If the file has no serial number, we assume it's ancient.
    test -n "$my_serial" || my_serial=0

    $ECHO $my_serial
}


# func_serial_max serial1 serial2
# Compare (possibly multi-part, '.' delimited) serial numbers, and
# return the largest in $func_serial_max_result.  If they are the
# same, func_serial_max_result will be empty.
func_serial_max ()
{
    $opt_debug
    my_serial1="$1"
    my_serial2="$2"

    my_sed_dot='s/\..*$//g'
    my_sed_rest='s/^[[0-9]][[1-9]]*\.*//'
    my_sed_digits='s/[[^0-9.]]//g'

    # Incase they turn out to be the same, we'll set it to empty
    func_serial_max_result=

    test "X$1$2" = X`$ECHO "X$1$2" | $Xsed -e "$my_sed_digits"` || {
      func_error "serial numbers \`$1' or \`$2' contain non-digit chars"
      return
    }

    while test -n "$my_serial1$my_serial2"; do
      my_serial1_part=`$ECHO "X$my_serial1" | $Xsed -e "$my_sed_dot"`
      my_serial2_part=`$ECHO "X$my_serial2" | $Xsed -e "$my_sed_dot"`

      test -z "$my_serial1_part$my_serial2_part" \
        && break

      test -z "$my_serial1_part" \
        && { func_serial_max_result="$2"; break; }

      test -z "$my_serial2_part" \
        && { func_serial_max_result="$1"; break; }

      test "$my_serial1_part" -gt "$my_serial2_part" \
        && { func_serial_max_result="$1"; break; }

      test "$my_serial2_part" -gt "$my_serial1_part" \
        && { func_serial_max_result="$2"; break; }

      my_serial1=`$ECHO "X$my_serial1" | $Xsed -e "$my_sed_rest"`
      my_serial2=`$ECHO "X$my_serial2" | $Xsed -e "$my_sed_rest"`
    done
}


# func_serial_update_check srcfile src_serial destfile dest_serial
# Unless SRC_SERIAL is newer than DEST_SERIAL set $func_serial_update_check
# to 'false'.
func_serial_update_check ()
{
    $opt_debug
    my_srcfile="$1"
    my_src_serial="$2"
    my_destfile="$3"
    my_dest_serial="$4"
    my_update_p=:

    if test -f "$my_destfile"; then
      test "X$my_src_serial" = "X0" && {
        func_error "warning: no serial number on \`$my_srcfile', not copying."
	return
      }

      # Determine whether the destination has an older serial.
      func_serial_max "$my_src_serial" "$my_dest_serial"
      test "X$my_src_serial" = "X$func_serial_max_result" || my_update_p=false

      test "X$my_src_serial" = "X$func_serial_max_result" \
        && func_verbose "\`$my_srcfile' is serial $my_src_serial, greater than $my_dest_serial in \`$my_destfile'"

      if test "X$my_dest_serial" = "X$func_serial_max_result"; then
        func_verbose "\`$my_srcfile' is serial $my_src_serial, less than $my_dest_serial in \`$my_destfile'"
	$opt_force \
	  || func_error "\`$my_destfile' is newer: use \`--force' to overwrite"
      fi
    fi

    func_serial_update_check_result="$my_update_p"
}


# func_serial_update filename srcdir destdir [macro_regex] [old_macro_regex]
# Copy the FILENAME from a SRCDIR to DESTDIR provided that either FILENAME
# has a newer serial number, or DESTFILE does not yet exist, or the user
# specified `--force' at the command line.  If given, MACRO_REGEX or
# OLD_MACRO_REGEX must match any text after "# serial N" in both files.
func_serial_update ()
{
    $opt_debug
    my_filename="$1"
    my_srcdir="$2"
    my_destdir="$3"
    my_macro_regex="$4"
    my_old_macro_regex="$5"

    my_serial_update_p=:
    my_return_status=1
    my_srcfile="$my_srcdir/$my_filename"
    my_destfile="$my_destdir/$my_filename"

    test -f "$my_srcfile" || {
      func_error "\`$my_srcfile' does not exist."
      return
    }

    if test -f "$my_destfile"; then
      my_src_serial=`func_serial "$my_srcfile" "$my_macro_regex"`
      my_dest_serial=`func_serial "$my_destfile" "$my_macro_regex"`

      # Strictly, this libtoolize ought not to have to deal with ancient
      # serial formats, but we accept them here to be complete:
      test "X$my_src_serial" = "X0" &&
        my_src_serial=`func_serial "$my_srcfile" "$my_old_macro_regex"`

      test "X$my_dest_serial" = "X0" &&
        my_dest_serial=`func_serial "$my_destfile" "$my_old_macro_regex"`

      func_serial_update_check \
        "$my_srcfile" "$my_src_serial" "$my_destfile" "$my_dest_serial"
      my_serial_update_p="$func_serial_update_check_result"
    fi

    if $my_serial_update_p || $opt_force; then
      func_copy "$my_srcfile" "$my_destfile"
      my_return_status=$?
    elif test "X$my_dest_serial" = "X$my_src_serial"; then
      $opt_quiet \
        || func_echo "\`$my_destfile' is already up to date."
    fi

    # Do this after the copy for hand maintained `aclocal.m4', incase
    # it has `m4_include([DESTFILE])', so the copy effectively already
    # updated `aclocal.m4'.
    $use_aclocal || if test -f aclocal.m4; then
      func_serial_max \
          "$my_src_serial" `func_serial aclocal.m4 "$my_macro_regex"`
      test "X$my_src_serial" = "X$func_serial_max_result" \
	  && func_echo "You should add the contents of \'$my_destfile' to \`aclocal.m4'."
    fi

    return $my_return_status
}


# func_keyword_update filename srcdir destdir sed_script
# Copy the FILENAME from a SRCDIR to DESTDIR provided that either FILENAME
# has a newer revision according to the serial number extracted by
# SED_SCRIPT, or DESTFILE does not yet exist, or the user specified
# `--force' at the command line.
func_keyword_update ()
{
    $opt_debug
    my_filename="$1"
    my_srcdir="$2"
    my_destdir="$3"
    my_sed_script="$4"

    my_srcfile="$my_srcdir/$my_filename"
    my_destfile="$my_destdir/$my_filename"

    my_keyword_update_p=:

    test -f "$my_srcfile" || {
      func_error "\`$my_srcfile' does not exist."
      return
    }

    if test -f "$my_destfile"; then
      my_src_serial=`$SED -e "$my_sed_script" "$my_srcfile"`
      test -z "$my_src_serial" && {
        func_error "warning: no serial number in \`$my_srcfile', not copying."
	return
      }

      my_dest_serial=`$SED -e "$my_sed_script" "$my_destfile"`
      test -n "$my_dest_serial" || my_dest_serial=0

      func_serial_update_check \
         "$my_srcfile" "$my_src_serial" "$my_destfile" "$my_dest_serial"
      my_keyword_update_p="$func_serial_update_check_result"
    fi

    if $my_keyword_update_p || $opt_force; then
      func_copy "$my_srcfile" "$my_destfile"
    elif test "X$my_dest_serial" = "X$my_src_serial"; then
      $opt_quiet \
        || func_echo "\`$my_destfile' is already up to date."
    fi
}


# func_ltmain_update filename srcdir destdir
# Copy the FILENAME from a SRCDIR to DESTDIR provided that either FILENAME
# has a newer revision, or DESTFILE does not yet exist, or the user
# specified `--force' at the command line.
func_ltmain_update ()
{
    $opt_debug
    my_sed_ltmain=['/^package_revision='\''*[0-9][1-9.]*'\''*/ {
      s,^package_revision='\''*\([0-9.]*\)'\''*[ 	]*$,\1,; p;
    };
    d']

    func_keyword_update "$1" "$2" "$3" "$my_sed_ltmain"

    return $my_return_status
}


# func_config_update filename srcdir destdir
# Copy the FILENAME from a SRCDIR to DESTDIR provided that either FILENAME
# has a newer timestamp, or DESTFILE does not yet exist, or the user
# specified `--force' at the command line.
func_config_update ()
{
    $opt_debug
    my_sed_config=['/^timestamp='\''*[0-9][1-9-]*'\''*/ {
      s,^timestamp='\''*\([0-9-]*\)'\''*,\1,; s/-/./g; p;
    };
    d']

    func_keyword_update "$1" "$2" "$3" "$my_sed_config"

    return $my_return_status
}


# func_install_update filename srcdir destdir
# Copy the FILENAME from a SRCDIR to DESTDIR provided that either FILENAME
# has a newer timestamp, or DESTFILE does not yet exist, or the user
# specified `--force' at the command line.
func_install_update ()
{
    $opt_debug
    my_sed_install=['/^scriptversion='\''*[0-9][1-9.-]*'\''*/ {
      s,^scriptversion='\''*\([0-9.-]*\)'\''*,\1,; s/-/./g; p;
    };
    d']

    func_keyword_update "$1" "$2" "$3" "$my_sed_install"

    return $my_return_status
}


# func_check_macros
# Sanity check macros from aclocal.m4 against installed versions.
func_check_macros ()
{
    $opt_debug
    # Don't trace for this, we're just checking the user didn't invoke it
    # directly from configure.ac.
    $SED 's,[d]nl .*$,,; s,# .*$,,' "$configure_ac" | grep AC_PROG_RANLIB \
      && func_echo "\`AC_PROG_RANLIB' is rendered obsolete by \`LT_INIT'"

    $seen_libtool \
      || func_echo "Remember to add \`LT_INIT' to \`$configure_ac'."

    # FIXME: Ensure ltmain.sh, libtool.m4 and ltdl.m4 are from the same release
}


# func_massage_nobase_pkgvdata_DATA [glob_exclude]
# @nobase_pkgvdata_DATA\@ is substituted as per its value in Makefile.am;
# this function massages it into a suitable format for func_copy_some_files.
func_massage_nobase_pkgvdata_DATA ()
{
    pkgvmacro_files=     # GLOBAL VAR

    my_glob_exclude="$1"

    # Massage a value for pkgvmacro_files from the value used in Makefile.am.
    for my_filename in @nobase_pkgvdata_DATA@; do
      my_filename=`$ECHO "X$my_filename" | $Xsed -e "$basename"`

      # ignore excluded filenames
      if test -n "$my_glob_exclude"; then
        eval 'case $my_filename in '$my_glob_exclude') continue ;; esac'
      fi

      pkgvmacro_files="$pkgvmacro_files:$my_filename"
    done

    # strip spurious leading `:'
    pkgvmacro_files=`$ECHO "X$pkgvmacro_files" | $Xsed -e 's,^:*,,'`
}


# func_massage_pkgvltdl_files [glob_exclude]
# @pkgvltdl_files\@ is substituted as per its value in Makefile.am; this
# function massages it into a suitable format for func_copy_some_files.
func_massage_pkgvltdl_files ()
{
    pkgvltdl_files=	# GLOBAL VAR

    my_glob_exclude="$1"

    # Massage a value for pkgvltdl_files from the value used in Makefile.am
    for my_filename in @pkgvltdl_files@; do

      # ignore excluded filenames
      if test -n "$my_glob_exclude"; then
        eval 'case $my_filename in '$my_glob_exclude') continue ;; esac'
      fi

      # ignore duplicates
      case :$pkgvltdl_files: in
        *:$my_filename:*) ;;
	*) pkgvltdl_files="$pkgvltdl_files:$my_filename" ;;
      esac
    done

    # strip spurious leading `:'
    pkgvltdl_files=`$ECHO "X$pkgvltdl_files" | $Xsed -e 's,^:*,,'`
}


## ----------- ##
##    Main.    ##
## ----------- ##

{
  rerun_aclocal=false

  func_massage_pkgvltdl_files

  # libtool.m4 and ltdl.m4 are handled specially below
  func_massage_nobase_pkgvdata_DATA 'libtool.m4|ltdl.m4'

  glob_exclude_pkgaux_files='config.guess|config.sub|install-sh|ltmain.sh'

  func_scan_files
  $opt_quiet || func_check_macros

  # Copy all the files from installed (or specified, if `-I' was used)
  # libltdl to this project, if the user specified `--ltdl'.
  if test -n "$ltdldir"; then
    func_copy_some_files "$pkgvltdl_files" "$_lt_pkgvdatadir/libltdl" "$ltdldir"

    # libtoolize the newly copied libltdl tree
    ( cd "$ltdldir" && eval "$progpath" $libtoolize_flags ) \
      || exit $EXIT_FAILURE
  fi

  # Copy all the installed utility files to the auxiliary directory if
  # `--install' was passed, or else copy just ltmain.sh.
  $opt_quiet || if test "$auxdir" != .; then
    func_echo "putting files in AC_CONFIG_AUX_DIR, \`$auxdir'."
  fi
  if $opt_install; then
    func_config_update config.guess "$_lt_pkgvdatadir/config" "$auxdir"
    func_config_update config.sub   "$_lt_pkgvdatadir/config" "$auxdir"
    func_install_update install-sh  "$_lt_pkgvdatadir/config" "$auxdir"
  fi
  func_ltmain_update ltmain.sh "$_lt_pkgvdatadir/config" "$auxdir"

  # Copy libtool's m4 macros to the macro directory, if they are newer.
  if test -n "$m4dir"; then
    $opt_quiet || func_echo "putting macros in AC_CONFIG_MACRO_DIR, \`$m4dir'."

    func_serial_update  libtool.m4 "$_lt_pkgvdatadir/m4" "$m4dir" \
      LT_INIT 'A[[CM]]_PROG_LIBTOOL'

    if $seen_ltdl; then
      func_serial_update ltdl.m4 "$_lt_pkgvdatadir/m4" "$m4dir" 'LTDL_INIT'
    else
      func_verbose "Not copying \`$m4dir/ltdl.m4', libltdl not used."
    fi

    func_copy_some_files "$pkgvmacro_files" "$_lt_pkgvdatadir/m4" \
      "$m4dir" func_serial_update
  else
    func_verbose "AC_CONFIG_MACRO_DIR not defined, not copying libtool macro files."
  fi
}

exit $exit_status

# Local Variables:
# mode:shell-script
# sh-indentation:2
# End:
