
AutoGen Definitions ltmain.tpl;

#define UNINSTALL_STRING 7

string[UNINSTALL_STRING] = {
  str-name = uninstall;
  use_explain = clean;
  use_cmd = clean;
};


#define CLEAN_STRING 1

string[CLEAN_STRING] = {
  str-name = clean;
  explain = "
<command> is the name of the program to use to delete files associated with
each FILE (typically `/bin/rm').  `<cmd-arg>-s' are options (such as `-f')
to be passed to <command>.

If one of the arguments specifies the removal of a libtool library, object
or program, all the files associated with it are deleted. Otherwise, only
the file itself is deleted using <command>.\n";

  text = << _END_EXECUTE_STRING_
[++ AutoGen5 Template ++]
    rm="$nonopt"
    files=
    rmforce=
    exit_status=0

    # This variable tells wrapper scripts just to set variables rather
    # than running their programs.
    libtool_install_magic="$magic"

    for arg
    do
      case $arg in
      -f) rm="$rm $arg"; rmforce=yes ;;
      -*) rm="$rm $arg" ;;
      *) files="$files $arg" ;;
      esac
    done

    if test -z "$rm"; then
      $echo "$modename: you must specify an RM program" 1>&2
      $echo "$help" 1>&2
      exit 1
    fi

    rmdirs=

    for file in $files; do
      dir=`$echo "X$file" | $Xsed -e 's%/[^/]*$%%'`
      if test "X$dir" = "X$file"; then
	dir=.
	objdir="$objdir"
      else
	objdir="$dir/$objdir"
      fi
      name=`$echo "X$file" | $Xsed -e 's%^.*/%%'`
      test $mode = uninstall && objdir="$dir"

      # Remember objdir for removal later, being careful to avoid duplicates
      if test $mode = clean; then
	case " $rmdirs " in
	  *" $objdir "*) ;;
	  *) rmdirs="$rmdirs $objdir" ;;
	esac
      fi

      # Don't error if the file doesn't exist and rm -f was used.
      if (test -L "$file") >/dev/null 2>&1 \
        || (test -h "$file") >/dev/null 2>&1 \
	|| test -f "$file"; then
        :
      elif test -d "$file"; then
        exit_status=1
	continue
      elif test "$rmforce" = yes; then
        continue
      fi

      rmfiles="$file"

      case $name in
      *.la)
	# Possibly a libtool archive, so verify it.
	if (sed -e '2q' $file | egrep "^# Generated by .*$PACKAGE") >/dev/null 2>&1; then
	  . $dir/$name

	  # Delete the libtool libraries and symlinks.
	  for n in $library_names; do
	    rmfiles="$rmfiles $objdir/$n"
	  done
	  test -n "$old_library" && rmfiles="$rmfiles $objdir/$old_library"
	  test $mode = clean && rmfiles="$rmfiles $objdir/$name $objdir/${name}i"

	  if test $mode = uninstall; then
	    if test -n "$library_names"; then
	      # Do each command in the postuninstall commands.
	      eval cmds=\"$postuninstall_cmds\"
	      IFS="${IFS= 	}"; save_ifs="$IFS"; IFS='~'
	      for cmd in $cmds; do
		IFS="$save_ifs"
		$show "$cmd"
		$run eval "$cmd"
		if test $? != 0 && test "$rmforce" != yes; then
		  exit_status=1
		fi
	      done
	      IFS="$save_ifs"
	    fi

	    if test -n "$old_library"; then
	      # Do each command in the old_postuninstall commands.
	      eval cmds=\"$old_postuninstall_cmds\"
	      IFS="${IFS= 	}"; save_ifs="$IFS"; IFS='~'
	      for cmd in $cmds; do
		IFS="$save_ifs"
		$show "$cmd"
		$run eval "$cmd"
		if test $? != 0 && test "$rmforce" != yes; then
		  exit_status=1
		fi
	      done
	      IFS="$save_ifs"
	    fi
	    # FIXME: should reinstall the best remaining shared library.
	  fi
	fi
	;;

      *.lo)
	# Possibly a libtool object, so verify it.
	if (sed -e '2q' $file | egrep "^# Generated by .*$PACKAGE") >/dev/null 2>&1; then

          # Read the .lo file
          . $dir/$name

	  # Add PIC object to the list of files to remove.
          if test -n "$pic_object" \
             && test "$pic_object" != none; then
	    rmfiles="$rmfiles $dir/$pic_object"
          fi

	  # Add non-PIC object to the list of files to remove.
          if test -n "$non_pic_object" \
             && test "$non_pic_object" != none; then
	    rmfiles="$rmfiles $dir/$non_pic_object"
          fi
	fi
	;;

      *)
	# Do a test to see if this is a libtool program.
	if test $mode = clean &&
	   (sed -e '4q' $file | egrep "^# Generated by .*$PACKAGE") >/dev/null 2>&1; then
	  relink_command=
	  . $dir/$file

	  rmfiles="$rmfiles $objdir/$name $objdir/${name}S.${objext}"
	  if test "$fast_install" = yes && test -n "$relink_command"; then
	    rmfiles="$rmfiles $objdir/lt-$name"
	  fi
	fi
	;;
      esac
      $show "$rm $rmfiles"
      $run $rm $rmfiles || exit_status=1
    done

    # Try to remove the ${objdir}s in the directories where we deleted files
    for dir in $rmdirs; do
      if test -d "$dir"; then
	$show "rmdir $dir"
	$run rmdir $dir >/dev/null 2>&1
      fi
    done
_END_EXECUTE_STRING_;
};


/*
 * Local Variables:
 * mode:shell-script
 * sh-indentation:2
 * End:
 *
 * lt_clean.def ends here */
