/* ltmain.c - C implementation of GNU Libtool
 *
 * Copyright (C) 1998-2000 Free Software Foundation, Inc.
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2, or (at your option)
 * any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this software; see the file COPYING.  If not, write to
 * the Free Software Foundation, Inc., 59 Temple Place, Suite 330,
 * Boston, MA 02111-1307 USA
 *
 * As a special exception to the GNU General Public License, if you
 * distribute this file as part of a program that contains a
 * configuration script generated by Autoconf, you may include it under
 * the same distribution terms that you use for the rest of that program.
 */

#include <sys/types.h>
#include <stdio.h>              /* printf */
#include <stdlib.h>             /* exit */
#include <string.h>
#include <unistd.h>
#include <errno.h>
#include <sys/stat.h>
#include <sys/wait.h>
#include <signal.h>

#include "ltopts.h"
#include "ltstr.h"

static char*   pzTarget = NULL;
static char*   pzSource = NULL;
static int     oldLibs  = 0;
static char*   pzPicMode = "default";
static int     xCompile = 0;

static void*
xmalloc( size_t s )
{
    void* p = malloc( s );
    if (p == NULL) {
        fprintf( stderr, "%s error: cannot allocate %d bytes\n",
                 libtoolOptions.pzProgPath );
        exit( EXIT_FAILURE );
    }
    return p;
}

tCC*
makeShellSafe( pzArg )
    tCC*   pzArg;
{
    tSCC    zSpecial[] = "\\\"$`[~#^&*(){}|;<>?' \t|]";
    tSCC*   pzProt     = zSpecial + 4;

    size_t  len = strlen( pzArg );
    char*   pz;

    if (strcspn( pzArg, zSpecial ) == len)
        return pzArg;

    pz = strchr( pzArg, '\'' );
    if (pz == NULL)
        return pzArg;

    do  {
        len += 3;
        pz = strchr( pz+1, '\'' );
    } while (pz != NULL);

    {
        char*   pzRes = malloc( len + 1 );
        pz = pzRes;
        for (;;) {
            char  ch = *(pzArg++);
            *(pz++) = ch;

            switch (ch) {
            case '\0':
                goto scan_done;

            case '\'':
                do  {
                    strcpy( pz, "\\'" );
                    pz += 2;
                } while (*pzArg == '\'');
                *(pz++) = '\'';
                break;

            default:
                break;
            }
        } scan_done:;

        return pzRes;
    }
}


static void
parseCompileOpts( pArgc, pArgv )
    int*    pArgc;
    char*** pArgv;
{
    tSCC    zTooManyTargets[] =
        "%s compile: you cannot specify `-o' more than once\n";
    tSCC    zNoTarget[] =
        "%s compile:  `-o' must specify an output file name\n";
    tSCC    zNoXcompile[] =
        "%s compile:  `-Xcompiler' must specify a cross compiler\n";
    tSCC    zEarlyOpts[] =
        "%s compile: error: you cannot supply options before the command\n";

    int     argc = *pArgc;
    char**  argv = *pArgv;

    tCC**   newArgv = xmalloc( sizeof( char* ) * (argc + 1) );
    int     newCt   = 0;

    tCC*    pzCmd   = NULL;
    int     i;

    for (i=0; i<argc; i++) {
        if (strncmp( argv[i], "-o", 2 ) == 0) {
            if (pzTarget != NULL) {
                fprintf( stderr, zTooManyTargets, libtoolOptions.pzProgPath );
                exit( EXIT_FAILURE );
            }
            if (argv[i][2] != '\0')
                pzTarget = (argv[i]) + 2;
            else {
                pzTarget = argv[ ++i ];
                if (pzTarget == NULL) {
                    fprintf( stderr, zNoTarget, libtoolOptions.pzProgPath );
                    exit( EXIT_FAILURE );
                }
            }

        } else if (strcmp( argv[i], "-static"         ) == 0) {
            oldLibs = 1;

        } else if (strcmp( argv[i], "-prefer-pic"     ) == 0) {
            pzPicMode = "yes";

        } else if (strcmp( argv[i], "-prefer-non-pic" ) == 0) {
            pzPicMode = "no";

        } else if (strcmp( argv[i], "-Xcompiler"      ) == 0) {
            if (argv[++i] == NULL) {
                fprintf( stderr, zNoXcompile, libtoolOptions.pzProgPath );
                exit( EXIT_FAILURE );
            }
            pzCmd = newArgv[ newCt++ ] = makeShellSafe( argv[i] );

        } else if (argv[i][0] == '-') {
            if (pzCmd == NULL) {
                fprintf( stderr, zEarlyOpts, libtoolOptions.pzProgPath );
                exit( EXIT_FAILURE );
            }
            newArgv[ newCt++ ] = makeShellSafe( argv[i] );

        } else if (pzCmd == NULL) {
            pzCmd = newArgv[ newCt++ ] = makeShellSafe( argv[i] );

        } else {
            if (pzSource != NULL)
                newArgv[ newCt++ ] = makeShellSafe( pzSource );
            pzSource = argv[i];
        }
    }

    if (pzSource == NULL) {
        fprintf( stderr, "%s compile: error: no source file to compile\n",
                 libtoolOptions.pzProgName );
        exit( EXIT_FAILURE );
    }

    newArgv[ newCt ] = NULL;
    *pArgc = newCt;
    *pArgv = (char**)newArgv;
}


    void
emitCompile( argc, argv )
    int argc;
    char** argv;
{
    tSCC zDbgFmt[]   = "set -x\n";
    tSCC zQuiet[]    = "run=\nshow=%s\n";
    tSCC zDynFmt[]   = "build_libtool_libs=%s\n";
    tSCC zStatic[]   = "build_old_libs=%s\n";
    tSCC zModeName[] = "modename='%s: %s'\n";
    tSCC zMode[]     = "mode='%s'\n";
    tSCC zCmdName[]  = "nonopt='%s'\nset --";
    tSCC zDlOpt[]    = "execute_dlfiles='";

    /*
     *  When we emit our script, we want the interpreter to invoke *US*
     *  if echo does not work right.
     */
    tSCC zChkEcho[]  = 
"\n\nif test \"X`($echo '\\t') 2>/dev/null`\" = 'X\\t'\n\
then  :\n\
else  echo='%s --echo --' ; fi\n";

    FILE* fp = HAVE_OPT( DRY_RUN ) ? stdout : popen( pz_shell, "w" );
    if (fp == (FILE*)NULL) {
        tSCC zErr[] = "%s error:  fs error %d (%s) on popen( \"%s\",\"w\")\n";
        fprintf( stderr, zErr, libtoolOptions.pzProgPath, errno,
                 strerror( errno ), pz_shell );
        exit( EXIT_FAILURE );
    }

#    define CKSERV if (signalReceived != 0) { \
     closeScript( fp ); if (scriptStatus == 0) scriptStatus = EXIT_FAILURE; \
     return; }

#    define CLOSEOK if (signalReceived != 0) { closeScript( fp ); return; }

    parseCompileOpts( &argc, &argv );

    /*
     *  Emit the default configuration set up at program configuration time
     */
    fputs( pz_ltconfig, fp );
    CKSERV;
    fputs( apz_mode_cmd[ 0 ], fp );
    CKSERV;
    fprintf( fp, zChkEcho, libtoolOptions.pzProgPath );
    CKSERV;

    fprintf( fp, zQuiet,  HAVE_OPT( QUIET )      ? ":"   : "\"$echo\"" );
    CKSERV;

    /*
     *  IF we have DYNAMIC or STATIC, then we override the configured
     *  values.  We emitted the configured values with `z_ltconfig'.
     */
    if (HAVE_OPT( DYNAMIC ) && (oldLibs == 0))
        fprintf( fp, zDynFmt, ENABLED_OPT( DYNAMIC ) ? "yes" : "no" );
    if (HAVE_OPT( STATIC ) || oldLibs)
        fprintf( fp, zStatic, ENABLED_OPT( STATIC )
                 ? "yes" : (oldLibs ? "yes" : "no") );

    if (HAVE_OPT( DEBUG )) {
        fprintf( stderr, "%s: enabling shell trace mode\n",
                 libtoolOptions.pzProgName );
        fputs( zDbgFmt, fp );
    }
    CKSERV;

    if (HAVE_OPT( DLOPEN )) {
        int    ct = STACKCT_OPT(  DLOPEN );
        char** al = STACKLST_OPT( DLOPEN );
        fputs( zDlOpt, fp );
        for (;;) {
            emitShellQuoted( *(al++), fp );
            if (--ct <= 0)
                break;
            fputc( ' ', fp ); /* between each value only */
        }
        fputs( "'\n", fp );
    }
    CKSERV;

    /*
     *  Insert our modal stuff and one shell option processing dinkleberry
     *  that one of the command scripts depends upon.
     */
    fprintf( fp, zModeName, libtoolOptions.pzProgName,
             libtoolOptions.pOptDesc[ OPT_VALUE_MODE ].pz_Name );
    CKSERV;
    fprintf( fp, zMode, libtoolOptions.pzProgName );
    CKSERV;

    if (pzTarget == NULL) {
        pzTarget = strrchr( pzSource, '/' );
        if (pzTarget == NULL)
            pzTarget = pzSource;
        else
            pzTarget++; 
    }

    fprintf( fp, "libobj='%s'\n", makeShellSafe( pzTarget ));
    CKSERV;

    fprintf( fp, "build_old_libs=%s\n", oldLibs ? "yes" : "no" );
    CKSERV;

    fprintf( fp, "pic_mode=%s\n", pzPicMode );
    CKSERV;

    fputs( "base_compile='", fp );
    for (;;) {
        fputs( *(argv++), fp );
        CKSERV;
        if (--argc <= 0)
            break;
        fputc( ' ', fp );
    }

    {
        struct stat stbf;

        if (stat( pzSource, &stbf ) != 0) do {
            char* pz = getenv( "source" );
            if (  (pz != NULL)
               && (stat( pz, &stbf ) == 0)) {
                pzSource = pz;
                break;
            }

            pz = getenv( "srcdir" );
            if (pz == NULL)
                pz = getenv( "VPATH" );

            if (pz != NULL) {
                char* p = xmalloc( strlen( pz ) + strlen( pzSource ) + 2 );
                sprintf( p, "%s/%s", pz, pzSource );
                if (stat( p, &stbf ) == 0)
                    pzSource = p;
                else
                    free( p );
            }
        } while (0);

        fprintf( fp, "'\nsrcfile='%s'\n", pzSource );
    }

    emitCommands( fp, apz_mode_cmd[ OPT_VALUE_MODE ]);
}
/*
 * Local Variables:
 * c-file-style: "stroustrup"
 * indent-tabs-mode: nil
 * End:
 * end of ltcompile.c */
