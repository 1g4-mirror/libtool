/* ltmain.c - C implementation of GNU Libtool
 *
 * Copyright (C) 1998-2000 Free Software Foundation, Inc.
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2, or (at your option)
 * any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this software; see the file COPYING.  If not, write to
 * the Free Software Foundation, Inc., 59 Temple Place, Suite 330,
 * Boston, MA 02111-1307 USA
 *
 * As a special exception to the GNU General Public License, if you
 * distribute this file as part of a program that contains a
 * configuration script generated by Autoconf, you may include it under
 * the same distribution terms that you use for the rest of that program.
 */

#include <stdio.h>              /* printf */
#include <stdlib.h>             /* exit */
#include <string.h>
#include <unistd.h>
#include <errno.h>
#include <sys/wait.h>
#include <signal.h>

#include "ltopts.h"
#include "ltstr.h"


    void
emitCompile( argc, argv )
    int argc;
    char** argv;
{
    tSCC zDbgFmt[]   = "set -x\n";
    tSCC zQuiet[]    = "run=\nshow=%s\n";
    tSCC zDynFmt[]   = "build_libtool_libs=%s\n";
    tSCC zStatic[]   = "build_old_libs=%s\n";
    tSCC zModeName[] = "modename='%s: %s'\n";
    tSCC zMode[]     = "mode='%s'\n";
    tSCC zCmdName[]  = "nonopt='%s'\nset --";
    tSCC zDlOpt[]    = "execute_dlfiles='";

    /*
     *  When we emit our script, we want the interpreter to invoke *US*
     *  if echo does not work right.
     */
    tSCC zChkEcho[]  = 
"\n\nif test \"X`($echo '\\t') 2>/dev/null`\" = 'X\\t'\n\
then  :\n\
else  echo='%s --echo --' ; fi\n";

    FILE* fp = HAVE_OPT( DRY_RUN ) ? stdout : popen( pz_shell, "w" );
    if (fp == (FILE*)NULL) {
        tSCC zErr[] = "%s error:  fs error %d (%s) on popen( \"%s\",\"w\")\n";
        fprintf( stderr, zErr, ltmainOptions.pzProgPath, errno,
                 strerror( errno ), pz_shell );
        exit( EXIT_FAILURE );
    }

#    define CKSERV if (signalReceived != 0) { \
     closeScript( fp ); if (scriptStatus == 0) scriptStatus = EXIT_FAILURE; \
     return; }

#    define CLOSEOK if (signalReceived != 0) { closeScript( fp ); return; }

    /*
     *  Emit the default configuration set up at program configuration time
     */
    fputs( pz_ltconfig, fp );
    CKSERV;
    fputs( apz_mode_cmd[ 0 ], fp );
    CKSERV;
    fprintf( fp, zChkEcho, ltmainOptions.pzProgPath );
    CKSERV;

    fprintf( fp, zQuiet,  HAVE_OPT( QUIET )      ? ":"   : "\"$echo\"" );
    CKSERV;

    /*
     *  IF we have DYNAMIC or STATIC, then we override the configured
     *  values.  We emitted the configured values with `z_ltconfig'.
     */
    if (HAVE_OPT( DYNAMIC ))
        fprintf( fp, zDynFmt, ENABLED_OPT( DYNAMIC ) ? "yes" : "no" );
    if (HAVE_OPT( STATIC ))
        fprintf( fp, zStatic, ENABLED_OPT( STATIC )  ? "yes" : "no" );

    if (HAVE_OPT( DEBUG )) {
        fprintf( stderr, "%s: enabling shell trace mode\n",
                 ltmainOptions.pzProgName );
        fputs( zDbgFmt, fp );
    }
    CKSERV;

    if (HAVE_OPT( DLOPEN )) {
        int    ct = STACKCT_OPT(  DLOPEN );
        char** al = STACKLST_OPT( DLOPEN );
        fputs( zDlOpt, fp );
        for (;;) {
            emitShellQuoted( *(al++), fp );
            if (--ct <= 0)
                break;
            fputc( ' ', fp ); /* between each value only */
        }
        fputs( "'\n", fp );
    }
    CKSERV;

    /*
     *  Insert our modal stuff and one shell option processing dinkleberry
     *  that one of the command scripts depends upon.
     */
    fprintf( fp, zModeName, ltmainOptions.pzProgName,
            ltmainOptions.pOptDesc[ WHICH_OPT_COMPILE ].pz_Name );
    CKSERV;
    fprintf( fp, zMode, ltmainOptions.pzProgName );
    CKSERV;

    /*
     *  Emit the real command.  The original shell script shifts off the
     *  command name before it realizes what it has done.  We emulate
     *  that behavior by setting `nonopt' to the command name and inserting
     *  the remaining arguments as arguments via `set -- $@'.
     */
    fprintf( fp, zCmdName, argv[0] );
    CKSERV;

    while (--argc > 0) {
        fputc( ' ', fp );
        emitShellArg( *(++argv), fp );
        CKSERV;
    }

    fputc( '\n', fp );
    fflush( fp );
    CKSERV;

    /*
     *  Up to now, we are just initializing variables.  Here, we write
     *  a large chunk of text to the pipe and the shell may exit before
     *  we are done.  If that happens, we get a SIGPIPE.  The `CLOSEOK'
     *  macro will detect that, call closeScript() and return so as to
     *  avoid segfaults and more SIGPIPEs.
     */
    fputs( apz_mode_cmd[ WHICH_OPT_COMPILE ], fp );
    CLOSEOK;

    fputc( '\n', fp );
    CLOSEOK;

    fflush( fp );

    if (fp != stdout)
        closeScript( fp );
}
