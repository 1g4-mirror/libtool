/* ltexe.c - C implementation of GNU Libtool
 *
 * Copyright (C) 1998-2000 Free Software Foundation, Inc.
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2, or (at your option)
 * any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this software; see the file COPYING.  If not, write to
 * the Free Software Foundation, Inc., 59 Temple Place, Suite 330,
 * Boston, MA 02111-1307 USA
 *
 * As a special exception to the GNU General Public License, if you
 * distribute this file as part of a program that contains a
 * configuration script generated by Autoconf, you may include it under
 * the same distribution terms that you use for the rest of that program.
 */

#include <stdio.h>              /* printf */
#include <stdlib.h>             /* exit */
#include <string.h>
#include <unistd.h>
#include <errno.h>
#include <sys/wait.h>
#include <signal.h>

#include "ltopts.h"
#include "ltstr.h"

/* BEGIN-STATIC-FORWARD */
/* END-STATIC-FORWARD */

EXPORT void
emitExecute( argc, argv )
    int    argc;
    char** argv;    /*end-decl*/
{
    tSCC zDbgFmt[]   = "set -x\n";
    tSCC zQuiet[]    = "run=\nshow=%s\n";
    tSCC zDynFmt[]   = "build_libtool_libs=%s\n";
    tSCC zStatic[]   = "build_old_libs=%s\n";
    tSCC zDupDeps[]  = "duplicate_deps=%s\n";
    tSCC zModeName[] = "modename='%s: %s'\n";
    tSCC zMode[]     = "mode='%s'\n";
    tSCC zCmdName[]  = "nonopt='%s'\nset --";

    /*
     *  When we emit our script, we want the interpreter to invoke *US*
     *  if echo does not work right.
     */
    tSCC zChkEcho[]  = 
"\n\nif test \"X`($echo '\\t') 2>/dev/null`\" = 'X\\t'\n\
then  :\n\
else  echo='%s --echo --' ; fi\n";

    FILE* fp = HAVE_OPT( DRY_RUN ) ? stdout : popen( pz_shell, "w" );
    if (fp == (FILE*)NULL) {
        tSCC zErr[] = "%s error:  fs error %d (%s) on popen( \"%s\",\"w\")\n";
        fprintf( stderr, zErr, libtoolOptions.pzProgPath, errno,
                 strerror( errno ), pz_shell );
        exit( EXIT_FAILURE );
    }

#    define CKSERV if (signalReceived != 0) { \
     closeScript( fp ); if (scriptStatus == 0) scriptStatus = EXIT_FAILURE; \
     return; }

#    define CLOSEOK if (signalReceived != 0) { closeScript( fp ); return; }

    /*
     *  Emit the default configuration set up at program configuration time
     */
    fputs( pz_ltconfig, fp );
    CKSERV;
    fputs( apz_mode_cmd[ 0 ], fp );
    CKSERV;
    fprintf( fp, zChkEcho, libtoolOptions.pzProgPath );
    CKSERV;

    fprintf( fp, zQuiet,  HAVE_OPT( QUIET )      ? ":"   : "\"$echo\"" );
    CKSERV;

    /*
     *  IF we have DYNAMIC or STATIC, then we override the configured
     *  values.  We emitted the configured values with `z_ltconfig'.
     */
    if (HAVE_OPT( DYNAMIC ))
        fprintf( fp, zDynFmt, ENABLED_OPT( DYNAMIC ) ? "yes" : "no" );
    if (HAVE_OPT( STATIC ))
        fprintf( fp, zStatic, ENABLED_OPT( STATIC )  ? "yes" : "no" );
    if (HAVE_OPT( PRESERVE_DUP_DEPS ))
		fprintf( fp, zDupDeps, "yes" );
	else
		fprintf( fp, zDupDeps, "no" );

    if (HAVE_OPT( DEBUG )) {
        fprintf( stderr, "%s: enabling shell trace mode\n",
                 libtoolOptions.pzProgName );
        fputs( zDbgFmt, fp );
    }
    CKSERV;

    if (HAVE_OPT( DLOPEN )) {
        emitDlopenOption( fp );
        CKSERV;
    }

    /*
     *  Insert our modal stuff and one shell option processing dinkleberry
     *  that one of the command scripts depends upon.
     */
    fprintf( fp, zModeName, libtoolOptions.pzProgName,
             apzModeName[ OPT_VALUE_MODE ]);
    CKSERV;
    fprintf( fp, zMode, libtoolOptions.pzProgName );
    CKSERV;

    /*
     *  Emit the real command.  The original shell script shifts off the
     *  command name before it realizes what it has done.  We emulate
     *  that behavior by setting `nonopt' to the command name and inserting
     *  the remaining arguments as arguments via `set -- $@'.
     */
    fprintf( fp, zCmdName, argv[0] );
    CKSERV;

    while (--argc > 0) {
        fputc( ' ', fp );
        emitShellArg( *(++argv), fp, NUL ); /* either single or double quotes */
        CKSERV;
    }

    emitCommands( fp, apz_mode_cmd[ OPT_VALUE_MODE ]);
}
/*
 * Local Variables:
 * c-file-style: "stroustrup"
 * indent-tabs-mode: nil
 * tab-width: 4
 * End:
 * end of ltcompile.c */
