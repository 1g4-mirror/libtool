m4_define([_m4_divert(SCRIPT)], 100)
m4_divert_push([SCRIPT])#!/bin/sh
# @configure_input@

# clcommit (GNU @PACKAGE@) version 2.0
# Written by Gary V. Vaughan <gary@gnu.org>
# and Alexandre Oliva <aoliva@redhat.com>

# Copyright (C) 1999, 2000, 2004, 2006, 2008 Free Software Foundation, Inc.
# This is free software; see the source for copying conditions.  There is NO
# warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.

# Clcommit is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# Clcommit is distributed in the hope that it will be useful, but
# WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with clcommit; see the file COPYING.  If not, a copy
# can be downloaded from http://www.gnu.org/licenses/gpl.html,
# or obtained by writing to the Free Software Foundation, Inc.,
# 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.

# Usage: $progname [OPTION]... [--] [filepattern ...]

# -a AUTHOR --author=AUTHOR    override changeset author name with AUTHOR
# -C FILE   --changelog=FILE   extract commit message from specified FILE
#           --debug            enable verbose shell tracing
# -n        --dry-run          don't commit anything
#           --fast             same as --force --first
# -F file   --file=FILE        read commit message from FILE
# -1        --first            extract first entry from ChangeLog, no git diff
# -f        --force            don't check (unless *followed* by -n), and just
#                              display commit message instead of running $PAGER
#           --from=ADDRESS     override default from ADDRESS in commit email
# -m msg    --message=STRING   set commit message to STRING
#           --msg=STRING          same as -m
# -p        --push             push the changes back to origin
# -r [FILE] --rcfile[=FILE]    read default option from FILE [./.clcommitrc]
# -s addr   --sendmail=ADDRESS send commit email of the differences to ADDRESS
#           --signature[=FILE] add FILE to the end of the email [~/.signature]
#           --signoff          add a Signed-off-by attribution at the end
# -S TEXT   --summary=TEXT     specify a TEXT subject line for the commit email
#           --tags             in conjunction with -p, also push tags
# -v        --verbose          run in verbose mode
#           --version          print version information
# -h,-?     --help             print short or long help message

# This script eases checking in changes to git-maintained projects
# with ChangeLog files.  It will check that there have been no
# conflicting commits in the CVS repository and print which files it
# is going to commit to stderr.  A list of files to compare and to
# check in can be given in the command line.  If it is not given, all
# files in the current working directory are considered for check in.

# The commit message will be extracted from the differences between a
# file named ChangeLog* in the commit list, or named after -C, and the
# one in the repository (unless a message was specified with `-m' or
# `-F').  An empty message is not accepted (but a blank line is).  If
# the message is acceptable, it will be presented for verification
# (and possible edition) using the $PAGER environment variable (or
# `more', if it is not set, or `cat', if the `-f' switch is given).
# If $PAGER exits successfully, the modified files (at that moment)
# are checked in, unless `-n' was specified, in which case nothing is
# checked in.

# Report bugs to <gary@gnu.org>

: ${GIT="git"}
: ${MAILNOTIFY="mailnotify"}
: ${MKSTAMP="mkstamp"}

test -f "libltdl/config/$MAILNOTIFY" && MAILNOTIFY="libltdl/config/$MAILNOTIFY"
test -f "libltdl/config/$MKSTAMP" && MKSTAMP="libltdl/config/$MKSTAMP"

PROGRAM=clcommit

AS_SHELL_SANITIZE
$as_unset CDPATH

m4_include([getopt.m4sh])

M4SH_VERBATIM([[
# Global variables:
opt_commit=:
opt_first=false
opt_push=false
opt_tags=false
opt_update=:
opt_verbose=false

git_flags=
mailnotify_flags=
sendmail_to=

exit_cmd=:

# try to find out whether read supports -r
if echo bt | tr b '\\' | { read -r line; test "X$line" = 'X\t'; } 2>/dev/null
then
  read_r='read -r'
else
  read_r=read
fi

# Locations for important files:
signature_file=
log_dir="`func_mktempdir`"
log_file="$log_dir/log"
push_conflicts="$log_dir/git_push.log"

trap '$RM -r "$log_dir"; exit $EXIT_FAILURE' 1 2 15

set -e

# Parse options once, thoroughly.  This comes as soon as possible in
# the script to make things like `clcommit --version' happen quickly.
{
  # sed scripts:
  my_sed_single_opt='1s/^\(..\).*$/\1/;q'
  my_sed_single_rest='1s/^..\(.*\)$/\1/;q'
  my_sed_long_opt='1s/^\(--[^=]*\)=.*/\1/;q'
  my_sed_long_arg='1s/^--[^=]*=//'

  # this just eases exit handling
  while test $# -gt 0; do
    opt="$1"
    shift
    case $opt in

      --author|-a)	test $# = 0 && func_missing_arg $opt && break
      			func_quote_for_eval "$1"
			git_flags="$git_flags --author=$func_quote_for_eval_result"
			shift
			;;

      --[cC]hange[lL]og|-C)
			test $# = 0 && func_missing_arg $opt && break
			if test -f "$1"; then :; else
			  func_error "ChangeLog file \`$1' does not exist"
			  break
			fi
			ChangeLog="$1"
			shift
			;;

      --debug)		func_echo "enabling shell trace mode"
	    		mailnotify_flags="$mailnotify_flags --debug"
			set -x
			;;

      --dry-run|-n)	opt_commit=false; opt_update=:		;;

      --fast)		set dummy --force --first ${1+"$@"}; shift	;;

      --file|-F)	test $# = 0 && func_missing_arg $opt && break
			if $opt_first || test -f "$log_file"; then
			  func_error "you can have at most one of -m, -F and -1"
			  break
			fi
			if cat < "$1" > "$log_file"; then :; else
			  break
			fi
			shift
			;;

      --first|-1)	if test -f "$log_File"; then
	    		  func_error "you can have at most one of -m, -F and -1"
			  break
			fi
			opt_first=:
			;;

      --force|-f)	opt_update=false; PAGER=cat		;;

      --from)		test $# = 0 && func_missing_arg $opt && break
      			func_quote_for_eval "$1"
			mailnotify_flags="$mailnotify_flags --from=$func_quote_for_eval_result"
			shift
			;;

      --message|--msg|-m)
			test $# = 0 && func_missing_arg $opt && break
			if $opt_first || test -f "$log_file"; then
			  func_error "you can have at most one of -m, -F and -1"
			  break
			fi
			echo "$1" > "$log_file"
			shift
			;;

      --push|-p)	opt_push=:				;;

      --rcfile|-r)	rc_file="./.clcommitrc"
			if test $# -gt 0; then
			  case $1 in
			    -*)				;;
			    *)  rc_file="$1"; shift	;;
			  esac
			fi
			if test -f "$rc_file"; then :; else
			  func_error "rcfile \`$rc_file' does not exist"
			  exit_cmd=exit
			  break
			fi
			# The funny quoting allows keeping one option per
			# line in $rc_file:
			eval set dummy `echo \`cat $rc_file\` \${1+"\$@"}`
			shift
			;;

      --sendmail|-s)	test $# = 0 && func_missing_arg $opt && break
      			func_quote_for_eval "$1"
      			sendmail_to="$func_quote_for_eval_result"
			shift
			;;

      --signature)	test $# = 0 && func_missing_arg $opt && break
    			signature_file="$HOME/.signature"
			case $1 in
			  -*) ;;
			  *)  signature_file="$1"; shift ;;
			esac
			if test -f "$signature_file"; then :; else
			  func_error "\`$signature_file': file not found"
			  break
			fi
			;;

      --signoff)	git_flags="$git_flags --signoff"	;;

      --summary|-S)	test $# = 0 && func_missing_arg $opt && break
			summary="$1"
			shift
			;;

      --tags)		opt_tags=:				;;

      --verbose|-v)	opt_verbose=:				;;

      # Separate optargs to long options:
      --*=*)
			arg=`echo "$opt" | $SED "$my_sed_long_arg"`
			opt=`echo "$opt" | $SED "$my_sed_long_opt"`
			set dummy "$opt" "$arg" ${1+"$@"}
			shift
			;;

      # Separate optargs to short options:
      -a*|-m*|-F*|-C*|-S*|-s*)
			arg=`echo "$opt" |$SED "$my_sed_single_rest"`
			opt=`echo "$opt" |$SED "$my_sed_single_opt"`
			set dummy "$opt" "$arg" ${1+"$@"}
			shift
			;;

      # Separate non-argument short options:
      -1*|-f*|-p*|-n*|-q*)
			rest=`echo "$opt" |$SED "$my_sed_single_rest"`
			opt=`echo "$opt" |$SED "$my_sed_single_opt"`
			set dummy "$opt" "-$rest" ${1+"$@"}
			shift
			;;

      -\?|-h)		func_usage					;;
      --help)		func_help					;;
      --version)	func_version					;;
      --)		break						;;
      -*)		func_fatal_help "unrecognized option \`$opt'"	;;
      *)		set dummy "$opt" ${1+"$@"};	shift; break		;;
    esac
  done

  if test -z "$sendmail_to"; then

    # can't have a from address without a destination address
    test -n "$sendmail_from" &&
      func_error "can't use --from without --sendmail." && exit_cmd=exit

    # can't use a signature file without a destination address
    test -n "$signature_file" &&
      func_error "can't use --signature without --sendmail." && exit_cmd=exit
  fi

  $opt_tags && test x"$opt_push" = xfalse &&
    func_error "can't use --tags without --push." && exit_cmd=exit

  # Bail if the options were screwed
  $exit_cmd $EXIT_FAILURE
}

# func_check_conflicts
func_check_conflicts ()
{
    if $GIT push --dry-run > "$push_conflicts" 2>&1; then :; else
      cat "$push_conflicts" >&2
      func_fatal_error "some conflicts were found with upstream repository, aborting..."
    fi
}


# func_check_commit_msg
func_check_commit_msg ()
{
    if test -z "$ChangeLog"; then
      for f in ${1+"$@"}; do
        case "$f" in
          ChangeLog* | */ChangeLog*)
            if test -z "$ChangeLog"; then
	      ChangeLog="$f"
	    else
	      func_fatal_error "multiple ChangeLog files: $ChangeLog and $f"
	    fi
	  ;;
        esac
      done
    fi

    func_verbose "$progname: checking commit message..."
    if $opt_first; then
      skipping=:
      $SED 's,^,+,' < ${ChangeLog-ChangeLog} |
        while $read_r line; do
          case "$line" in
            "+") if $skipping; then skipping=false; else break; fi;;
            "+ "*)
	      func_error "*** Warning: lines should start with tabs, not spaces; ignoring line:"
	      echo "$line" | $SED 's/^.//' >&2;;
            "+	"*)
              $skipping || echo "$line" ;;
          esac
        done |
          $SED 's,^\+	,,' > "$log_file" || exit $EXIT_FAILURE
    else
      $GIT diff ${ChangeLog-ChangeLog} |
        while $read_r line; do
          case $line in
            "--- "*) :;;
            "-"*)
	      func_error "*** Warning: the following line in ChangeLog diff is suspicious:"
	      echo "$line" | $SED 's/^.//' >&2;;
            "+ "*)
	      func_error "*** Warning: lines should start with tabs, not spaces; ignoring line:"
	      echo "$line" | $SED 's/^.//' >&2;;
            "+") echo ;;
            "+	"*) echo "$line";;
          esac
        done |
          $SED -e 's,\+	,,' -e '/./p' -e '/./d' -e '1d' -e '$d' > "$log_file" \
      || exit $EXIT_FAILURE
    fi
    # The sed script above removes "+TAB" from the beginning of a line, then
    # deletes the first and/or the last line, when they happen to be empty
}


# func_commit
func_commit ()
{
    ${PAGER-more} "$log_file" || exit $EXIT_FAILURE

    sleep 1 # give the user some time for a ^C

    subject=`git status 2>/dev/null | $SED -n 's/^#.*[mad][ode][dl].*ed: *//p'`
    test $# -gt 0 && subject="$@"

    test $# -gt 0 || { set dummy -a; shift; }
    func_verbose "$GIT commit$git_flags -F $log_file ${1+$@}"
    $GIT commit$git_flags -F $log_file ${1+"$@"} || exit $EXIT_FAILURE

    if $opt_push; then
      $GIT push
      $opt_tags && $GIT push --tags
    fi

    :
}


# func_mailnotify
func_mailnotify ()
{
    notify_file="${log_dir}/notify"
    func_verbose "Mailing commit notification to $sendmail_to"

    {
      echo Subject: $subject
      test -f .git/config &&
          echo "Root:		`$SED -n 's,^	url = .*:\(.*\)$,\1,p' .git/config`"
      test -f $MKSTAMP &&
          echo "Timestamp:	`$SHELL $MKSTAMP .`"
      echo "Branch:		`$GIT branch | sed -n 's/\* //p'`"
      test -f .git/config &&
          echo "Changes by:	`$SED -n 's,^	url = \([^:]*\):.*$,\1,p' .git/config`"
      echo ""
      echo "Log Message:"
      $SED -e 's,^,	,' "$log_file"
      test -f "$signature_file" && {
        echo '-- '
	cat "$signature_file"
      }
    } > "$notify_file"

    ${PAGER-more} "$notify_file" || break

    # Break out the subject line again
    my_mail_subject=`$SED -e '
        1{
	    s/^Subject: *//
	    q
	}' "$notify_file"`
    my_mail_body=`$SED -e '2,$p;d' "$notify_file"`
    echo "$my_mail_body" > "$notify_file"

    func_verbose "mailing commit notification to \"$sendmail_to\""
    func_quote_for_eval "$my_mail_subject"
    func_show_eval "$MAILNOTIFY $mailnotify_flags \
        -s $func_quote_for_eval_result -m 'text/plain' -f '$notify_file' \
	-- $sendmail_to"
}



## ----- ##
## main. ##
## ----- ##

{
  test -f "$log_file" || func_check_commit_msg

  grep '[^ 	]' < "$log_file" > /dev/null ||
    func_fatal_error "empty commit message, aborting"

  if grep '^$' < "$log_file" > /dev/null; then
    func_error "*** Warning: blank lines should not appear within commit messages."
    func_error "*** They should be used to separate distinct commits."
  fi

  $opt_update && $opt_push && func_check_conflicts

  # Do not check for empty $log_file again, even though the user might have
  # zeroed it out.  If s/he did, it was probably intentional.
  if $opt_commit; then
    func_commit ${1+"$@"}
  fi

  # Send a copy of the log_file if sendmail_to was set:
  subject=`sed -n '1p' "$log_file"`
  if test -n "$sendmail_to"; then
    if ! $opt_push; then
      func_warning "Mail notification NOT sent for commit to local repository."
    else
      func_mailnotify
    fi
  fi

  $RM -r "$log_dir"
}

exit $EXIT_SUCCESS

# Local Variables:
# mode:shell-script
# sh-indentation:2
# End:
]])

