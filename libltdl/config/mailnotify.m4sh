AS_INIT[]m4_divert_push([HEADER-COPYRIGHT])dnl
# @configure_input@

# mailnotify (GNU @PACKAGE@) version 0.6
# Written by Gary V. Vaughan <gary@gnu.org>

# Copyright (C) 2004, 2006 Free Software Foundation, Inc.
# This is free software; see the source for copying conditions.  There is NO
# warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.

# Mailnotify is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# Mailnotify is distributed in the hope that it will be useful, but
# WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with mailnotify; see the file COPYING.  If not, a copy
# can be downloaded from http://www.gnu.org/licenses/gpl.html,
# or obtained by writing to the Free Software Foundation, Inc.,
# 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.

# Usage: $progname [OPTION]... [--] to-address...
#
#           --debug             enable verbose shell tracing
# -C ADDR   --carbon-copy=ADDR  send a carbon-copy to ADDR
# -F ADDR   --from=ADDR         override default from address with ADDR
# -f FILE   --filename=FILE     content of this part
# -m TYPE   --mime-type=TYPE    mime-type of this part
# -n                            another mime part (-f, -m) to follow
# -o FILE   --output-file=FILE  output to FILE instead of sending
# -s TEXT   --subject=TEXT      set subject header
# -v        --verbose           run in verbose mode
#           --version           print version information
# -h,-?     --help              print short or long help message

# Assemble a (possibly multi-part) mime message and hand it to the local
# sendmail for onward delivery.  MUAs tend to mangle patch attachments in
# various ways: not setting the mime-type correctly, line wrapping the
# patch itself, escaping certain values, etc.  This script is designed to
# make it easier to send a patch as a MIME attachment, though it is general
# enough that it might be useful otherwise.

# For example to send a patch as an attachment, assuming the patch itself
# is in PATCHFILE:
#
#    echo 'Applied to HEAD' > body
#    $progname -f body -m text/plain -n -f PATCHFILE -m text/x-patch \
#        -s 'FYI: PATCHFILE' patch-list@foo.org

# You will probably find using this script in conjunction with clcommit
# or cvsapply will save you an awful lot of typing.

# Report bugs to <gary@gnu.org>

: ${HOST=`hostname`}
: ${SENDMAIL=sendmail}

PROGRAM=mailnotify

m4_divert_pop
m4_include([getopt.m4sh])

M4SH_VERBATIM([[
# Global variables:
multipart=1
outputfile=""

sed_mail_address='s,^.*<\(.*\)>.*$,\1,'

# Parse options once, thoroughly.  This comes as soon as possible in
# the script to make things like `mailnotify --version' happen quickly.
{
  # sed scripts:
  my_sed_single_opt='1s/^\(..\).*$/\1/;q'
  my_sed_single_rest='1s/^..\(.*\)$/\1/;q'
  my_sed_long_opt='1s/^\(--[^=]*\)=.*/\1/;q'
  my_sed_long_arg='1s/^--[^=]*=//'

  while test $# -gt 0; do
    opt="$1"
    shift
    case $opt in
      --debug)		func_echo "enabling shell trace mode"
			set -x
			;;

      -C|--carbon-copy) test $# -eq 0 && func_missing_arg "$opt" && break
	    		func_quote_for_eval "$1"
			cc="$func_quote_for_eval_result"
			shift
			;;

      -F|--from)	test $# -eq 0 && func_missing_arg "$opt" && break
	    		func_quote_for_eval "$1"
			from="$func_quote_for_eval_result"
			shift
			;;

      -f|--filename)	test $# -eq 0 && func_missing_arg "$opt" && break
			if test -f "$1"; then :; else
			  func_error "\`$1' does not exist"
			  exit_cmd=exit
			  break
			fi
			eval datafile$multipart=\"$1\"
			shift
			;;

      -m|--mime-type)	test $# -eq 0 && func_missing_arg "$opt" && break
			case $1 in
			  text/*) ;;
			  */*) func_error "only text/* mime-types supported"
			       ;;
			  *)   func_error "invalid mime-type, \`$1'"
			       exit_cmd=exit
			       ;;
			esac
			eval ctype$multipart=\"$1\"
			shift
			;;

      -n)		if eval test -z \"\$ctype$multipart\" ||
			   eval test -z \"\$datafile$multipart\"; then
			  func_fatal_error "One part is incomplete -- each part needs a filename and a mime-type"
			fi
			multipart=`expr 1 + $multipart`
			;;

      -o|--output-file)	test $# -eq 0 && func_missing_arg "$opt" && break
	    		func_quote_for_eval "$1"
			outputfile="$func_quote_for_eval_result"
			shift
			;;

      -s|--subject)	test $# -eq 0 && func_missing_arg "$opt" && break
	    		func_quote_for_eval "$1"
			subject="$func_quote_for_eval_result"
			shift
			;;

      -v|--verbose)	opt_verbose=:			;;

      # Separate optargs to long options:
      --carbon-copy=*|--from=*|--filename=*|--mime-type=*|--output-file=*|--subject=*)
			arg=`echo "$opt" | $SED "$my_sed_long_arg"`
			opt=`echo "$opt" | $SED "$my_sed_long_opt"`
			set -- "$opt" "$arg" ${1+"$@"}
			;;

      # Separate optargs to short options:
      -C*|-F*|-f*|-m*|-o*|-s*)
			arg=`echo "$opt" |$SED "$my_sed_single_rest"`
			opt=`echo "$opt" |$SED "$my_sed_single_opt"`
			set -- "$opt" "$arg" ${1+"$@"}
			;;

      # Separate non-argument short options:
      -n*|-v*)
			rest=`echo "$opt" |$SED "$my_sed_single_rest"`
			opt=`echo "$opt" |$SED "$my_sed_single_opt"`
			set -- "$opt" "-$rest" ${1+"$@"}
			;;

      -\?|-h)		func_usage					;;
      --help)		func_help					;;
      --version)	func_version					;;
      --)		break						;;
      -*)		func_fatal_help "unrecognized option \`$opt'"	;;
      *)		set -- "$opt" ${1+"$@"};      break		;;
    esac
  done

  test $# -gt 0 ||
    func_fatal_help "no destination address"

  if test -z "$outputfile"; then
    if test -z "$subject" ||
       eval test -z \"\$ctype$multipart\" ||
       eval test -z \"\$datafile$multipart\"; then
      func_fatal_error "if output is not directed to a file -s, -f, and -m are all required"
    fi
  else
    eval test -n \"\$datafile$multipart\" ||
        func_fatal_error "-f is required."
    eval test -n \"\$ctype$multipart\" ||
        func_fatal_error "with output directed to a file, -m is required"
  fi
  eval test -f \"\$datafile$multipart\" ||
    eval func_fatal_error \"\$datafile$multipart: file not found\"
}


# func_headers outfile destination
# Generate common headers to OUTFILE, where DESTINATION is a comma
# separated list of fully qualified destination addresses.
func_headers ()
{
    my_outfile="$1"
    my_destination="$2"
    my_sed_version_no='
	/^# '$PROGRAM' (GNU / {
	    s/^# .*version //
	    p
	}
	d'

    {
	echo "User-Agent: $PROGRAM/`$SED \"$my_sed_version_no\" < $progpath`"
	echo "MIME-Version: 1.0"
	test -n "$from" && eval echo From: $from
	eval echo To: $my_destination
	test -n "$cc" && eval echo CC: $cc
	test -n "$subject" && eval echo Subject: $subject
    } > "$my_outfile"
}


# func_single_content outfile
# Send the only message part as a single mime mail part.
func_single_content ()
{
    my_outfile="$1"

    cat >> "$my_outfile" <<EOF
Content-Type: $ctype1;
Content-Transfer-Encoding: 7bit

`cat $datafile1`
EOF
}


# func_multipart_content outfile
# Send the various message parts to OUTFILE as a multipart mime mail.
func_multipart_content ()
{
    my_outfile="$1"
    boundary="boundary-${HOST}-$$-`date | tr ' :' -`"
    cat <<EOF >> "$my_outfile"
Content-Type: multipart/mixed;
	boundary="$boundary"

This is a multimedia message in MIME format.  If you are reading
this prefix, your mail reader does not understand MIME.  You may
wish to look into upgrading to a mime-aware mail reader.
EOF
    i=0
    while test $i -lt $multipart
    do
      i=`expr 1 + $i`
      eval file=\"\$datafile$i\"
      name=`echo "$file" | $SED $basename`
      {
	echo ""
	echo "--$boundary"
	if test $i -gt 1; then
	    eval echo \"Content-Type: \$ctype$i\;\"
	    echo "        name=\"$name\""
	else
	    eval echo \"Content-Type: \$ctype$i\"
	fi
	echo "Content-Transfer-Encoding: 7bit"
	echo ""
	cat "$file"
      } >> "$my_outfile"
    done
    {
      echo ""
      echo "--${boundary}--"
      echo ""
    } >> "$my_outfile"
}


# func_sendmail infile destination [from]
# Send the message in INFILE to the space delimited list of destination
# addresses in DESTINATION.  If FROM is given, it is the address the
# mail purports to be from.
# BEWARE: Many MTAs will refuse mail where FROM does not match the actual
#         sending domain.
func_sendmail ()
{
    my_infile="$1"
    my_destination="$2"
    my_from="$3"

    from_name=`eval echo "X$my_from" | $Xsed -e 's, *<.*> *$,,'`
    from_addr=`eval echo "X$my_from" | $Xsed -e "$sed_mail_address"`

    save_PATH="$PATH"
    PATH="/usr/lib:/usr/sbin:$PATH"

    save_IFS="$IFS"
    IFS=':'
    for try_sendmail_dir in $PATH; do
        IFS="$save_IFS"
	PATH="$save_PATH"
	if test -x "$try_sendmail_dir/$SENDMAIL"; then
	    SENDMAIL="$try_sendmail_dir/$SENDMAIL"
	    break
	fi
    done
    IFS="$save_IFS"
    PATH="$save_PATH"
    test -x "$SENDMAIL" || func_fatal_error "sendmail executable not found"

    func_verbose "Delivering mail, please wait..."
    if test -n "$from_name"; then
        $SENDMAIL -F "$from_name" -f "$from_addr" $my_destination < "$my_infile"
    elif test -n "$from_addr"; then
        $SENDMAIL -f "$from_addr" $my_destination < "$my_infile"
    else
        $SENDMAIL $my_destination < "$my_infile"
    fi
    if test $? -eq 0; then
        func_verbose "...succeeded."
        $RM $my_infile
    else
        func_fatal_error "Mail delivery failed, draft mail is in $my_infile"
    fi
}



## ----- ##
## main. ##
## ----- ##

{
  tmp_dir="`func_mktempdir`"
  fname="$tmp_dir/mail"
  trap '$RM -r "$tmp_dir"; exit $EXIT_FAILURE' 1 2 15

  # Generate a comma separated list of destination addresses for the
  # mail headers:
  destination=""
  for to in : ${1+"$@"}
  do
      test "X$to" = X: && continue

      func_quote_for_eval "$to"

      case $destination in
	  "") destination="$func_quote_for_eval_result" ;;
          *)  destination="$destination, $func_quote_for_eval_result" ;;
      esac
  done

  func_headers "$fname" "$destination"
  if test $multipart -gt 1; then
      func_multipart_content "$fname"
  else
      func_single_content "$fname"
  fi

  # Generate a space delimited list of destination addresses for sendmail:
  if test -z "$outputfile"; then
      destination=""
      for to in : ${1+"$@"}
      do
          test "X$to" = X: && continue

	  func_quote_for_eval "$to"

          to_addr=`echo "$func_quote_for_eval_result" | sed "$sed_mail_address"`
	  test -n "$to_addr" || to_addr="$func_quote_for_eval_result"
	  destination="$destination $to_addr"
      done
      func_sendmail "$fname" "$destination" "$from"
  else
      mv $fname $outputfile || exit $EXIT_FAILURE
  fi

  $RM -r "$tmp_dir"
}

exit $EXIT_SUCCESS

# Local Variables:
# mode:shell-script
# sh-indentation:2
# End:
]])

