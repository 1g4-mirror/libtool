# -*- sh -*-
# Defines for Libtool testing environment.
# Gord Matzigkeit <gord@gnu.ai.mit.edu>, 1996
# Gary V. Vaughan <gary@gnu.org>, 2003

# Copyright (C) 2003, 2004 Free Software Foundation, Inc.
# This is free software; see the source for copying conditions.  There is NO
# warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.

# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful, but
# WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
# General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, a copy can be downloaded from
# http://www.gnu.org/copyleft/gpl.html, or by writing to the Free
# Software Foundation, Inc., 59 Temple Place - Suite 330, Boston,
# MA 02111-1307, USA.

# Be Bourne compatible
if test -n "${ZSH_VERSION+set}" && (emulate sh) >/dev/null 2>&1; then
  emulate sh
  NULLCMD=:
  # Zsh 3.x and 4.x performs word splitting on ${1+"$@"}, which
  # is contrary to our usage.  Disable this feature.
  alias -g '${1+"$@"}'='"$@"'
  setopt NO_GLOB_SUBST
elif test -n "${BASH_VERSION+set}${KSH_VERSION+set}" && (set -o posix) >/dev/null 2>&1; then
  set -o posix
fi
DUALCASE=1; export DUALCASE # for MKS sh

# The HP-UX ksh and POSIX shell print the target directory to stdout
# if CDPATH is set.
(unset CDPATH) >/dev/null 2>&1 && unset CDPATH

: ${AUTOCONF="autoconf"}
: ${ECHO="echo"}
: ${GREP="grep"}
: ${LIBTOOL="../libtool"}
: ${MAKE="make"}
: ${MKDIR="mkdir"}		# FIXME: Use @mkdir_p@ substitution for make -j
: ${SED="sed"}
: ${SHELL="${CONFIG_SHELL-/bin/sh}"}

# FIXME: Substitute @EGREP@ and @FGREP@ from the Makefile too
if $ECHO a | ($GREP -E '(a|b)') >/dev/null 2>&1; then
  EGREP="$GREP -E"
else
  EGREP='egrep'
fi
if $ECHO 'ab*c' | ($GREP -F 'ab*c') >/dev/null 2>&1; then
  FGREP="$GREP -F"
else
  FGREP='fgrep'
fi

basename='s,^.*/,,g'
dirname='s,/[^/]*$,,'

# Work around backward compatibility issue on IRIX 6.5. On IRIX 6.4+, sh
# is ksh but when the shell is invoked as "sh" and the current value of
# the _XPG environment variable is not equal to 1 (one), the special
# positional parameter $0, within a function call, is the name of the
# function.
progpath="$0"

# The name of this program:
progname=`$ECHO "$progpath" | $SED "$basename"`

# Make sure we have an absolute path for reexecution:
case $progpath in
  [\\/]*|[A-Za-z]:\\*) ;;
  *) progdir=`$ECHO "$progpath" | $SED "$dirname"`
     progdir=`cd "$progdir" && pwd`
     progpath="$progdir/$progname"
     ;;
esac

# Check that srcdir is set to an absolute path.
case "$srcdir" in
/* | [A-Za-z]:\\*) ;;
*) srcdir=`cd $srcdir && pwd` ;;
esac

# Global variables:
EXIT_SUCCESS=0
EXIT_FAILURE=1
EXIT_SKIP=77  # $? = 77 is used to indicate a skipped test to automake

# Disable usage of config.site for autoconf, unless DJGPP is present.
# The DJGPP port of autoconf requires config.site, to work correctly.
if test -z "$DJGPP"; then
    CONFIG_SITE=/nonexistent
fi

# See how redirections should work.
test "${VERBOSE+set}" != "set" && VERBOSE=no
case "$VERBOSE" in
NO | no | 0 | "")
  exec > /dev/null 2>&1
  ;;
esac


# func_msg arg...
# Echo message with prefix.
func_msg ()
{
    $ECHO "=" ${1+"$@"}
}

# func_error arg...
# Echo message to standard error.
func_error ()
{
    $ECHO ${1+"$@"} 1>&2
}

# func_skip arg...
# Echo message to standard error, and skip the rest of this test.
func_skip ()
{
    func_error ${1+"$@"}
    exit $EXIT_SKIP
}

# func_fail arg...
# Echo message to standard error, and fail this test.
func_fail ()
{
    func_error ${1+"$@"}
    exit $EXIT_FAILURE
}

# func_get_config varname_list src [failp] [regex]
func_get_config ()
{
  my_varname_list="$1"
  my_src="$2"
  my_failp="false";  test -z "$3" || my_failp=:
  my_regex="$4"

  my_exitp=false
  for my_varname in $my_varname_list; do
    test -z "$4" && my_regex="^${my_varname}="

    eval $my_varname=NONE
    eval `eval $my_src | eval $GREP \"$my_regex\"`

    if eval test x\"\$$my_varname\" = xNONE; then
      func_error "$my_varname not set in \`$my_src'"
      $my_failp && my_exitp=:
    fi
  done

  $my_exitp && exit $EXIT_FAILURE
}


# Extract objext from the libtool configuration
func_get_config "objext" "$LIBTOOL --config" ": fatal"

# Extract objdir from the libtool configuration
func_get_config "objdir" "$LIBTOOL --config" ": fatal"

# Extract CC from the libtool configuration
func_get_config "CC" "$LIBTOOL --config" ": fatal"

# Extract host from the libtool configuration
func_get_config "host" "$LIBTOOL --config" ": fatal"


# func_grep expression filename
# Check whether EXPRESSION matches any line of FILENAME, without output.
func_grep ()
{
    $GREP "$1" "$2" >/dev/null 2>&1
}

# func_mkdir_p dir
# Make sure the entire path to DIR is available.
func_mkdir_p ()
{
    my_dir=$1
    my_dirs=

    while test ! -d "$my_dir"; do
      my_dirs="$my_dir $my_dirs"
      case $my_dir in */*) ;; *) break ;; esac
      my_dir=`$ECHO "$my_dir" | $SED "$dirname"`
    done
   test ! -n "$my_dirs" || $MKDIR $my_dirs
}

# func_mkprefixdir
func_mkprefixdir ()
{
    # An absolute path to a test installation directory.
    func_mkdir_p "$prefix"
    prefix=`cd $prefix && pwd`
}

# func_rmprefixdir
func_rmprefixdir ()
{
    test -d $prefix && rm -rf $prefix
    prefix=NONE
}

# func_cd dir
# Make sure a directory exists, and then change to it.
func_cd ()
{
    my_dir="$1"

    # Maybe we have a VPATH build, in which case, create a new subdir.
    func_mkdir_p "$my_dir"

    # Change to our build directory.
    cd "$my_dir" || exit 1
}


# func_require prereq file [...]
# If FILE does not exist, give a fatal error regarding running PREREQ first.
func_require ()
{
    my_prereq="$1"; shift
    my_files=${1+"$@"}

    for my_file in $my_files; do
      test -f "$my_file" \
        || func_skip "You must run ${my_prereq}.test before running $0"
    done
}

# func_configure [args ...]
# Configure the demonstration.
func_configure ()
{
    my_args=${1+"$@"}
    my_dir=`pwd | $SED "$basename"`
    my_testdir="$srcdir/$my_dir"

    test -n "$my_args" && my_args=" $my_args"
    my_args="--srcdir="\""$my_testdir"\"" --prefix="\""$prefix"\""$my_args"

    func_msg "Configuring in $my_dir"

    test -f "$my_testdir/configure" || autoreconf --force --install $my_testdir
    test -f "$my_testdir/configure" || exit $EXIT_FAILURE

    eval func_msg $SHELL "$my_testdir/configure" $my_args
    eval $SHELL "$my_testdir/configure" $my_args || \
      { func_msg "FAILED: Configuring in $my_testdir"
        ls -ltr $my_testdir
        eval $SHELL -vx "$my_testdir/configure" $my_args;
	exit $EXIT_FAILURE;
      }
}

# func_check_static_shared staticp sharedp
# Determine whether the generated libtool script is configured properly
# for the expected STATICP and SHAREDP library building
func_check_static_shared ()
{
    my_staticp="$1"
    my_sharedp="$2"

    if func_grep "^build_old_libs=$staticp" libtool &&
       func_grep "^build_libtool_libs=$sharedp" libtool; then :
    else
      rm -f Makefile
      exit $EXIT_FAIL
    fi
}


# func_make [args ...]
# Do the actual build.
func_make ()
{
    my_args=${1+"$@"}
    my_dir=`pwd | $SED "$basename"`

    func_msg "Running \`$MAKE $my_args' in $my_dir"

    eval $MAKE $my_args || exit $EXIT_FAIL
}


# func_distclean
# Possibly clean up the distribution.
func_make_distclean ()
{
    if test -f Makefile; then
      func_make distclean
    fi
    rm -rf autom4te.cache config.cache
}


# func_make_uninstall
# See that there were no files leftover in $prefix.
# Ignore dotfiles, so that .nfsXXX files don't screw up the test.
func_make_uninstall ()
{
    func_make uninstall

    leftovers=`find $prefix ! -type d ! -name '.*' -print`
    if test -n "$leftovers"; then
      func_msg "Leftover after make uninstall:"
      ls -l $leftovers
      exit 1
    fi
}


# func_exec_init mode
func_exec_init ()
{
    func_msg "Executing $1 programs in $my_dir"

    # Windows hosts search for dlls in the command path
    PATH=$prefix/lib:$PATH

    exec_status=$EXIT_SUCCESS
}

# func_exec_check program [msg ...]
# Check to see if PROGRAM was built. If not display MSG.
func_exec_check ()
{
    my_program="$1"

    if test -f "$my_program"; then :
    else
      shift
      func_error "$0: $my_program did not build ${1+$@}"
      exec_status=$EXIT_FAILURE
    fi
}

# func_exec program [exp_output] [msg ...]
# Check to see if PROGRAM really runs, and produces EXP_OUTPUT if given.
# If not display MSG.
func_exec ()
{
    my_program="$1"
    my_exp_output="$2"
    my_dir=`pwd | $SED "$basename"`

    test -n "$my_exp_output" \
      && my_exp_output="| $EGREP -e "\""$my_exp_output"\"

    if eval $my_program $my_exp_output; then :
    else
      shift; shift
      func_error "$0: cannot execute $my_program ${1+$@}"

      # Simple check to see if they are superuser.
      if test $exec_status = $EXIT_FAILURE || test -w /; then :
      else
        func_msg "You may need to run $0 as the superuser."
      fi
      exec_status=$EXIT_FAILURE
    fi
}

# Shared global variables for test scripts
prefix="./_inst"
scripts="$srcdir/../config/ltmain.sh ../libtoolize"

$ECHO "=== Running $progname"
